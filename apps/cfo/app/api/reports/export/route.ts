/**
 * CFO — Report export API route.
 *
 * Supports CSV and PDF export of financial reports.
 * GET /api/reports/export?reportId=...&format=csv|pdf
 */
import { NextRequest, NextResponse } from 'next/server'
import { authenticateUser, withRequestContext } from '@/lib/api-guards'
import { withSpan } from '@nzila/os-core/telemetry'
import { platformDb } from '@nzila/db/platform'
import { sql } from 'drizzle-orm'
import { logger } from '@/lib/logger'

interface ReportRow {
  id: string
  title: string
  type: string
  status: string
  period: string
  createdAt: string
  generatedBy: string
  narrative: string | null
  entityId: string | null
}

export async function GET(request: NextRequest) {
  return withRequestContext(request, () =>
    withSpan('api.reports.export', { 'http.method': 'GET' }, async () => {
      const auth = await authenticateUser()
      if (!auth.ok) return auth.response

      const { searchParams } = new URL(request.url)
      const reportId = searchParams.get('reportId')
      const format = searchParams.get('format') ?? 'csv'

      try {
        let rows: ReportRow[]

        if (reportId) {
          // Single report export
          const result = (await platformDb.execute(
            sql`SELECT id, metadata->>'title' as title, metadata->>'type' as type,
              metadata->>'status' as status, metadata->>'period' as period,
              created_at as "createdAt", actor_id as "generatedBy",
              metadata->>'narrative' as narrative, entity_id as "entityId"
            FROM audit_log WHERE id = ${reportId}
            AND (action = 'report.generated' OR action = 'report.created')`,
          )) as unknown as { rows: ReportRow[] }
          rows = result.rows ?? []
        } else {
          // Export all reports
          const result = (await platformDb.execute(
            sql`SELECT id, metadata->>'title' as title, metadata->>'type' as type,
              metadata->>'status' as status, metadata->>'period' as period,
              created_at as "createdAt", actor_id as "generatedBy",
              metadata->>'narrative' as narrative, entity_id as "entityId"
            FROM audit_log
            WHERE action = 'report.generated' OR action = 'report.created'
            ORDER BY created_at DESC LIMIT 500`,
          )) as unknown as { rows: ReportRow[] }
          rows = result.rows ?? []
        }

        if (rows.length === 0) {
          return NextResponse.json({ error: 'No reports found' }, { status: 404 })
        }

        if (format === 'pdf') {
          // Generate a simple text-based PDF using raw PDF formatting
          const pdfContent = generateSimplePdf(rows)
          return new NextResponse(pdfContent as unknown as BodyInit, {
            headers: {
              'Content-Type': 'application/pdf',
              'Content-Disposition': `attachment; filename="ledgeriq-reports-${new Date().toISOString().slice(0, 10)}.pdf"`,
            },
          })
        }

        // Default: CSV export
        const csv = generateCsv(rows)
        return new NextResponse(csv, {
          headers: {
            'Content-Type': 'text/csv; charset=utf-8',
            'Content-Disposition': `attachment; filename="ledgeriq-reports-${new Date().toISOString().slice(0, 10)}.csv"`,
          },
        })
      } catch (error) {
        logger.error('Report export failed', { error })
        return NextResponse.json({ error: 'Export failed' }, { status: 500 })
      }
    }),
  )
}

function escapeCsv(value: string | null | undefined): string {
  if (!value) return ''
  const s = String(value)
  if (s.includes(',') || s.includes('"') || s.includes('\n')) {
    return `"${s.replace(/"/g, '""')}"`
  }
  return s
}

function generateCsv(rows: ReportRow[]): string {
  const headers = ['Report ID', 'Title', 'Type', 'Status', 'Period', 'Generated At', 'Generated By', 'Entity ID', 'Narrative Summary']
  const lines = [headers.join(',')]

  for (const row of rows) {
    lines.push(
      [
        escapeCsv(row.id),
        escapeCsv(row.title),
        escapeCsv(row.type),
        escapeCsv(row.status),
        escapeCsv(row.period),
        escapeCsv(row.createdAt),
        escapeCsv(row.generatedBy),
        escapeCsv(row.entityId),
        escapeCsv(row.narrative),
      ].join(','),
    )
  }

  return lines.join('\n')
}

function generateSimplePdf(rows: ReportRow[]): Uint8Array {
  // Minimal valid PDF structure - produces a two-column text-based report
  // For production, consider using a library like @react-pdf/renderer or pdfkit
  const title = `LedgerIQ Financial Reports — ${new Date().toISOString().slice(0, 10)}`
  const pageLines: string[] = [title, '', '']

  for (const row of rows) {
    pageLines.push(`Report: ${row.title ?? 'Untitled'}`)
    pageLines.push(`  Type: ${row.type ?? '-'}  |  Status: ${row.status ?? '-'}  |  Period: ${row.period ?? '-'}`)
    pageLines.push(`  Generated: ${row.createdAt ?? '-'}`)
    if (row.narrative) {
      const narrative = row.narrative.length > 300 ? row.narrative.slice(0, 300) + '…' : row.narrative
      pageLines.push(`  Summary: ${narrative}`)
    }
    pageLines.push('')
  }

  const textContent = pageLines.join('\n')

  // Build a minimal but valid PDF
  const streamContent = `BT\n/F1 10 Tf\n36 756 Td\n12 TL\n${textContent
    .split('\n')
    .map((line) => `(${line.replace(/[()\\]/g, '\\$&')}) '`)
    .join('\n')}\nET`

  const objects: string[] = []
  const offsets: number[] = []
  let pos = 0

  const header = '%PDF-1.4\n'
  pos += header.length

  // Object 1: Catalog
  offsets.push(pos)
  const obj1 = '1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n'
  objects.push(obj1)
  pos += obj1.length

  // Object 2: Pages
  offsets.push(pos)
  const obj2 = '2 0 obj\n<< /Type /Pages /Kids [3 0 R] /Count 1 >>\nendobj\n'
  objects.push(obj2)
  pos += obj2.length

  // Object 3: Page
  offsets.push(pos)
  const obj3 = '3 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 4 0 R /Resources << /Font << /F1 5 0 R >> >> >>\nendobj\n'
  objects.push(obj3)
  pos += obj3.length

  // Object 4: Stream
  offsets.push(pos)
  const obj4 = `4 0 obj\n<< /Length ${streamContent.length} >>\nstream\n${streamContent}\nendstream\nendobj\n`
  objects.push(obj4)
  pos += obj4.length

  // Object 5: Font
  offsets.push(pos)
  const obj5 = '5 0 obj\n<< /Type /Font /Subtype /Type1 /BaseFont /Courier >>\nendobj\n'
  objects.push(obj5)
  pos += obj5.length

  // Cross-reference table
  const xrefPos = pos
  const xref = `xref\n0 6\n0000000000 65535 f \n${offsets.map((o) => String(o).padStart(10, '0') + ' 00000 n ').join('\n')}\n`

  const trailer = `trailer\n<< /Size 6 /Root 1 0 R >>\nstartxref\n${xrefPos}\n%%EOF`

  const pdfString = header + objects.join('') + xref + trailer
  return new TextEncoder().encode(pdfString)
}
