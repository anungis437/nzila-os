/**
 * render.ts — Core rendering engine: copy template files, replace placeholders,
 *             manage lockfile, and apply overrides.
 */

import path from "node:path";
import fs from "fs-extra";
import crypto from "node:crypto";
import pc from "picocolors";
import { type PlaceholderValues, replacePlaceholders } from "./placeholders.js";
import {
  resolveFiles,
  listChapterFiles,
} from "./moduleResolver.js";

const GENERATED_HEADER_MD = "<!-- AUTO-GENERATED by nzila-scripts-book-template — do not edit directly -->\n\n";
const GENERATED_HEADER_SH = "# AUTO-GENERATED by nzila-scripts-book-template — do not edit directly\n";
const GENERATED_HEADER_PS1 = "# AUTO-GENERATED by nzila-scripts-book-template — do not edit directly\n";
const GENERATED_HEADER_PY = "# AUTO-GENERATED by nzila-scripts-book-template — do not edit directly\n";
const GENERATED_HEADER_YML = "# AUTO-GENERATED by nzila-scripts-book-template — do not edit directly\n";
const GENERATED_HEADER_DOCKER = "# AUTO-GENERATED by nzila-scripts-book-template — do not edit directly\n";

export interface LockEntry {
  hash: string;
  relativePath: string;
}

export interface Lockfile {
  template_version: string;
  applied_modules: string[];
  timestamp: string;
  files: LockEntry[];
}

function sha256(content: string): string {
  return crypto.createHash("sha256").update(content, "utf-8").digest("hex");
}

function getHeader(filePath: string): string {
  const ext = path.extname(filePath).toLowerCase();
  const base = path.basename(filePath).toLowerCase();
  if (ext === ".md") return GENERATED_HEADER_MD;
  if (ext === ".sh") return GENERATED_HEADER_SH;
  if (ext === ".ps1") return GENERATED_HEADER_PS1;
  if (ext === ".py") return GENERATED_HEADER_PY;
  if (ext === ".yml" || ext === ".yaml") return GENERATED_HEADER_YML;
  if (base.startsWith("dockerfile") || base === "dockerignore")
    return GENERATED_HEADER_DOCKER;
  return "";
}

/** Determine if an existing file was modified by the user (hash doesn't match lockfile). */
function wasUserModified(
  filePath: string,
  content: string,
  lockfile: Lockfile | null,
  relativePath: string,
): boolean {
  if (!lockfile) return false;
  const entry = lockfile.files.find((f) => f.relativePath === relativePath);
  if (!entry) return false;
  // The file existed in the previous generation — check if hash still matches
  const existingContent = fs.readFileSync(filePath, "utf-8");
  return sha256(existingContent) !== entry.hash;
}

export interface RenderOptions {
  templateRoot: string;
  targetDir: string;
  placeholders: PlaceholderValues;
  modules: string[];
  profile: string;
  options: {
    enable_ci: boolean;
    enable_deploy_workflows: boolean;
  };
  templateVersion: string;
  updateMode: boolean;
}

export interface RenderResult {
  written: string[];
  skipped: string[];
  lockfile: Lockfile;
}

export async function renderToTarget(opts: RenderOptions): Promise<RenderResult> {
  const {
    templateRoot,
    targetDir,
    placeholders,
    modules,
    profile,
    options,
    templateVersion,
    updateMode,
  } = opts;

  const written: string[] = [];
  const skipped: string[] = [];
  const lockEntries: LockEntry[] = [];

  // Load existing lockfile if in update mode
  let existingLock: Lockfile | null = null;
  const lockPath = path.join(targetDir, "scripts-book.lock.json");
  if (updateMode && (await fs.pathExists(lockPath))) {
    existingLock = await fs.readJson(lockPath);
  }

  const resolved = await resolveFiles(templateRoot, modules, profile, options);

  // Helper: render and write a file
  async function writeRendered(
    srcPath: string,
    destRelative: string,
  ): Promise<void> {
    const destPath = path.join(targetDir, destRelative);
    let content = await fs.readFile(srcPath, "utf-8");
    content = replacePlaceholders(content, placeholders);

    const header = getHeader(destRelative);
    // Only add header if file doesn't already start with a shebang, comment header, or HTML comment
    if (header && !content.startsWith("#!") && !content.startsWith("<!--") && !content.startsWith("# AUTO-GENERATED")) {
      content = header + content;
    }

    const hash = sha256(content);

    // In update mode, skip user-modified files
    if (updateMode && (await fs.pathExists(destPath))) {
      if (wasUserModified(destPath, content, existingLock, destRelative)) {
        console.log(pc.yellow(`  ⚠ Skipped (user-modified): ${destRelative}`));
        skipped.push(destRelative);
        // Keep the old hash in the lock so we can detect changes next time
        const oldEntry = existingLock?.files.find(
          (f) => f.relativePath === destRelative,
        );
        if (oldEntry) lockEntries.push(oldEntry);
        return;
      }
    }

    await fs.ensureDir(path.dirname(destPath));
    await fs.writeFile(destPath, content, "utf-8");
    written.push(destRelative);
    lockEntries.push({ hash, relativePath: destRelative });
  }

  // 1. Render scripts-book chapters
  for (const chapter of resolved.chapters) {
    const chapterFiles = await listChapterFiles(templateRoot, chapter);
    for (const relFile of chapterFiles) {
      const srcPath = path.join(
        templateRoot,
        "template",
        "scripts-book",
        relFile,
      );
      const destRelative = path.join("scripts-book", relFile);
      await writeRendered(srcPath, destRelative);
    }
  }

  // 2. Render docs
  for (const doc of resolved.docs) {
    const srcPath = path.join(templateRoot, "template", "docs", doc);
    if (await fs.pathExists(srcPath)) {
      await writeRendered(srcPath, path.join("docs", doc));
    }
  }

  // 3. Render workflows
  if (resolved.includeWorkflows) {
    const workflowDir = path.join(
      templateRoot,
      "template",
      "github",
      "workflows",
    );
    if (options.enable_ci) {
      const src = path.join(workflowDir, "verify.yml");
      if (await fs.pathExists(src)) {
        await writeRendered(src, path.join(".github", "workflows", "verify.yml"));
      }
    }
    if (options.enable_deploy_workflows) {
      for (const wf of ["deploy-staging.yml", "deploy-production.yml"]) {
        const src = path.join(workflowDir, wf);
        if (await fs.pathExists(src)) {
          await writeRendered(src, path.join(".github", "workflows", wf));
        }
      }
    }
  }

  // 4. Render Dockerfile
  if (resolved.dockerTemplate) {
    const src = path.join(
      templateRoot,
      "template",
      "docker",
      resolved.dockerTemplate,
    );
    if (await fs.pathExists(src)) {
      await writeRendered(src, resolved.dockerTemplate);
    }
    // Also copy dockerignore
    const ignoreSrc = path.join(templateRoot, "template", "docker", "dockerignore");
    if (await fs.pathExists(ignoreSrc)) {
      await writeRendered(ignoreSrc, ".dockerignore");
    }
  }

  // 5. Apply overrides (scripts-book-overrides/ and docs-overrides/)
  const sbOverrides = path.join(targetDir, "scripts-book-overrides");
  if (await fs.pathExists(sbOverrides)) {
    console.log(pc.blue("  Applying scripts-book overrides..."));
    await fs.copy(sbOverrides, path.join(targetDir, "scripts-book"), {
      overwrite: true,
    });
  }
  const docsOverrides = path.join(targetDir, "docs-overrides");
  if (await fs.pathExists(docsOverrides)) {
    console.log(pc.blue("  Applying docs overrides..."));
    await fs.copy(docsOverrides, path.join(targetDir, "docs"), {
      overwrite: true,
    });
  }

  // 6. Write lockfile
  const lockfile: Lockfile = {
    template_version: templateVersion,
    applied_modules: modules,
    timestamp: new Date().toISOString(),
    files: lockEntries,
  };
  await fs.writeJson(lockPath, lockfile, { spaces: 2 });

  return { written, skipped, lockfile };
}
