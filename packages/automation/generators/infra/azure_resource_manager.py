#!/usr/bin/env python3
"""
Azure Resource Manager — Unified infrastructure provisioning for Nzila platforms

Manages Azure resources with a unified strategy:
- Resource groups organized by vertical + environment
- Azure Container Apps for application hosting
- Azure PostgreSQL Flexible Servers for databases
- Managed Identities for OIDC authentication
- Azure Container Registry (shared)
- Monitoring and logging
"""

import json
import subprocess
from pathlib import Path
from typing import Dict, List, Optional, Any
from dataclasses import dataclass


@dataclass
class AzureConfig:
    """Azure configuration"""
    subscription_id: Optional[str] = None
    base_region: str = "canadacentral"
    base_resource_group: str = "rg-nzila-shared"
    container_registry_name: str = "nzilaregistry"
    log_analytics_workspace: str = "nzila-logs"


class AzureResourceManager:
    """Manages Azure resources for Nzila platforms"""
    
    def __init__(self, config: AzureConfig = None):
        self.config = config or AzureConfig()
        self._check_azure_cli()
    
    def _check_azure_cli(self):
        """Check if Azure CLI is installed"""
        try:
            result = subprocess.run(
                ["az", "--version"],
                capture_output=True,
                text=True,
                check=False
            )
            if result.returncode != 0:
                print("Warning: Azure CLI not found. Install from: https://aka.ms/install-az-cli")
                return False
            return True
        except FileNotFoundError:
            print("Warning: Azure CLI not found. Install from: https://aka.ms/install-az-cli")
            return False
    
    def generate_resource_names(self, platform_id: str, environment: str = "prod") -> Dict[str, str]:
        """Generate standardized Azure resource names"""
        # Sanitize platform ID for Azure naming (no special chars, lowercase)
        sanitized_id = platform_id.replace("-", "").replace("_", "").lower()
        
        return {
            "resource_group": f"rg-nzila-{platform_id}-{environment}",
            "container_app_env": f"cae-nzila-{platform_id}-{environment}",
            "container_app": f"ca-{sanitized_id}-{environment}",
            "postgres_server": f"psql-{sanitized_id}-{environment}",
            "postgres_database": f"{sanitized_id}_db",
            "managed_identity": f"id-{platform_id}-{environment}",
            "key_vault": f"kv-{sanitized_id[:12]}-{environment[:4]}",  # Key Vault has 24 char limit
            "log_analytics": self.config.log_analytics_workspace
        }
    
    def generate_bicep_template(self, platform_id: str, manifest: Dict[str, Any], 
                                 environment: str = "prod") -> str:
        """Generate Bicep infrastructure as code template"""
        resources = self.generate_resource_names(platform_id, environment)
        
        bicep = f"""// Azure Infrastructure for {manifest['product_name']}
// Generated by Nzila Migration Orchestration System

param location string = '{self.config.base_region}'
param environment string = '{environment}'
param containerImage string = '{self.config.container_registry_name}.azurecr.io/{manifest['image_repo']}:latest'

// Resource Group is created at deployment scope

// Container Apps Environment
resource containerAppEnv 'Microsoft.App/managedEnvironments@2023-05-01' = {{
  name: '{resources["container_app_env"]}'
  location: location
  properties: {{
    appLogsConfiguration: {{
      destination: 'log-analytics'
      logAnalyticsConfiguration: {{
        customerId: logAnalytics.properties.customerId
        sharedKey: logAnalytics.listKeys().primarySharedKey
      }}
    }}
  }}
}}

// Log Analytics Workspace
resource logAnalytics 'Microsoft.OperationalInsights/workspaces@2022-10-01' = {{
  name: '{resources["log_analytics"]}'
  location: location
  properties: {{
    sku: {{
      name: 'PerGB2018'
    }}
    retentionInDays: 30
  }}
}}

// PostgreSQL Flexible Server
resource postgresServer 'Microsoft.DBforPostgreSQL/flexibleServers@2023-03-01-preview' = {{
  name: '{resources["postgres_server"]}'
  location: location
  sku: {{
    name: 'Standard_B1ms'
    tier: 'Burstable'
  }}
  properties: {{
    version: '15'
    administratorLogin: 'nzilaadmin'
    administratorLoginPassword: '@Microsoft.KeyVault(VaultName=${{keyVault.name}};SecretName=postgres-admin-password)'
    storage: {{
      storageSizeGB: 32
    }}
    backup: {{
      backupRetentionDays: 7
      geoRedundantBackup: 'Disabled'
    }}
    highAvailability: {{
      mode: 'Disabled'
    }}
  }}
}}

// PostgreSQL Database
resource postgresDatabase 'Microsoft.DBforPostgreSQL/flexibleServers/databases@2023-03-01-preview' = {{
  parent: postgresServer
  name: '{resources["postgres_database"]}'
  properties: {{
    charset: 'UTF8'
    collation: 'en_US.utf8'
  }}
}}

// Managed Identity
resource managedIdentity 'Microsoft.ManagedIdentity/userAssignedIdentities@2023-01-31' = {{
  name: '{resources["managed_identity"]}'
  location: location
}}

// Key Vault
resource keyVault 'Microsoft.KeyVault/vaults@2023-02-01' = {{
  name: '{resources["key_vault"]}'
  location: location
  properties: {{
    sku: {{
      family: 'A'
      name: 'standard'
    }}
    tenantId: subscription().tenantId
    accessPolicies: [
      {{
        tenantId: subscription().tenantId
        objectId: managedIdentity.properties.principalId
        permissions: {{
          secrets: ['get', 'list']
        }}
      }}
    ]
  }}
}}

// Container App
resource containerApp 'Microsoft.App/containerApps@2023-05-01' = {{
  name: '{resources["container_app"]}'
  location: location
  identity: {{
    type: 'UserAssigned'
    userAssignedIdentities: {{
      '${{managedIdentity.id}}': {{}}
    }}
  }}
  properties: {{
    managedEnvironmentId: containerAppEnv.id
    configuration: {{
      ingress: {{
        external: true
        targetPort: {manifest['app_port']}
        transport: 'auto'
      }}
      secrets: [
        {{
          name: 'database-url'
          value: 'postgresql://nzilaadmin@${{postgresServer.name}}:@${{postgresServer.properties.fullyQualifiedDomainName}}:5432/{resources["postgres_database"]}?sslmode=require'
        }}
      ]
    }}
    template: {{
      containers: [
        {{
          name: '{manifest['image_repo']}'
          image: containerImage
          env: [
            {{
              name: 'DATABASE_URL'
              secretRef: 'database-url'
            }}
            {{
              name: 'CLERK_SECRET_KEY'
              secretRef: 'clerk-secret'
            }}
            {{
              name: 'NODE_ENV'
              value: environment
            }}
          ]
          resources: {{
            cpu: json('0.5')
            memory: '1Gi'
          }}
        }}
      ]
      scale: {{
        minReplicas: 1
        maxReplicas: 10
      }}
    }}
  }}
}}

output containerAppFQDN string = containerApp.properties.configuration.ingress.fqdn
output postgresServerFQDN string = postgresServer.properties.fullyQualifiedDomainName
output databaseName string = postgresDatabase.name
"""
        return bicep
    
    def generate_github_workflow(self, platform_id: str, manifest: Dict[str, Any]) -> str:
        """Generate GitHub Actions workflow for deployment"""
        resources = self.generate_resource_names(platform_id, "prod")
        
        workflow = f"""name: Deploy {manifest['product_name']}

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  AZURE_RESOURCE_GROUP: {resources["resource_group"]}
  AZURE_CONTAINER_APP: {resources["container_app"]}
  AZURE_CONTAINER_REGISTRY: {self.config.container_registry_name}
  IMAGE_NAME: {manifest['image_repo']}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Azure Login (OIDC)
        uses: azure/login@v1
        with:
          client-id: ${{{{ secrets.AZURE_CLIENT_ID }}}}
          tenant-id: ${{{{ secrets.AZURE_TENANT_ID }}}}
          subscription-id: ${{{{ secrets.AZURE_SUBSCRIPTION_ID }}}}
      
      - name: Build and push to ACR
        run: |
          az acr build \\
            --registry {self.config.container_registry_name} \\
            --image $IMAGE_NAME:latest \\
            --image $IMAGE_NAME:${{{{ github.sha }}}} \\
            .
      
      - name: Deploy to Container App
        run: |
          az containerapp update \\
            --name $AZURE_CONTAINER_APP \\
            --resource-group $AZURE_RESOURCE_GROUP \\
            --image ${{{{ACR_LOGIN_SERVER}}}}/$IMAGE_NAME:latest
        env:
          ACR_LOGIN_SERVER: {self.config.container_registry_name}.azurecr.io
"""
        return workflow
    
    def provision_shared_resources(self, dry_run: bool = False):
        """Provision shared Azure resources"""
        print("="*60)
        print("PROVISIONING SHARED RESOURCES")
        print("="*60)
        
        commands = [
            # Create shared resource group
            f"az group create --name {self.config.base_resource_group} --location {self.config.base_region}",
            
            # Create shared container registry
            f"az acr create --name {self.config.container_registry_name} --resource-group {self.config.base_resource_group} --sku Basic",
            
            # Create shared log analytics workspace
            f"az monitor log-analytics workspace create --workspace-name {self.config.log_analytics_workspace} --resource-group {self.config.base_resource_group} --location {self.config.base_region}"
        ]
        
        if dry_run:
            print("Dry run - would execute:")
            for cmd in commands:
                print(f"  {cmd}")
        else:
            for cmd in commands:
                print(f"Executing: {cmd}")
                result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
                if result.returncode == 0:
                    print("✓ Success")
                else:
                    print(f"✗ Failed: {result.stderr}")
    
    def generate_all_infrastructure(self, manifests: Dict[str, Any], output_dir: Path):
        """Generate infrastructure code for all platforms"""
        output_dir = Path(output_dir)
        output_dir.mkdir(exist_ok=True, parents=True)
        
        for platform_id, manifest in manifests.items():
            platform_dir = output_dir / platform_id
            platform_dir.mkdir(exist_ok=True)
            
            # Generate Bicep template
            bicep_content = self.generate_bicep_template(platform_id, manifest)
            bicep_file = platform_dir / "main.bicep"
            with open(bicep_file, "w") as f:
                f.write(bicep_content)
            
            # Generate GitHub workflow
            workflow_content = self.generate_github_workflow(platform_id, manifest)
            workflow_file = platform_dir / "deploy.yml"
            with open(workflow_file, "w") as f:
                f.write(workflow_content)
            
            # Generate deployment instructions
            readme = self._generate_deployment_readme(platform_id, manifest)
            with open(platform_dir / "README.md", "w") as f:
                f.write(readme)
            
            print(f"✓ Generated infrastructure for {platform_id}")
        
        print(f"\nInfrastructure code generated in: {output_dir}")
    
    def _generate_deployment_readme(self, platform_id: str, manifest: Dict[str, Any]) -> str:
        """Generate deployment instructions"""
        resources = self.generate_resource_names(platform_id, "prod")
        
        return f"""# {manifest['product_name']} - Azure Infrastructure

## Resources

- **Resource Group**: `{resources['resource_group']}`
- **Container App**: `{resources['container_app']}`
- **PostgreSQL Server**: `{resources['postgres_server']}`
- **Database**: `{resources['postgres_database']}`

## Deployment

### Prerequisites

1. Azure CLI installed
2. Logged in: `az login`
3. Correct subscription: `az account set --subscription <subscription-id>`

### Deploy Infrastructure

```bash
# Create resource group
az group create \\
  --name {resources['resource_group']} \\
  --location {self.config.base_region}

# Deploy Bicep template
az deployment group create \\
  --resource-group {resources['resource_group']} \\
  --template-file main.bicep
```

### Configure Secrets

```bash
# Set PostgreSQL admin password
az keyvault secret set \\
  --vault-name {resources['key_vault']} \\
  --name postgres-admin-password \\
  --value '<strong-password>'

# Set Clerk secret key
az keyvault secret set \\
  --vault-name {resources['key_vault']} \\
  --name clerk-secret \\
  --value '${{{{ secrets.CLERK_SECRET_KEY }}}}'
```

### GitHub OIDC Setup

1. Create Azure AD App Registration
2. Add federated credentials for GitHub
3. Set GitHub secrets:
   - `AZURE_CLIENT_ID`
   - `AZURE_TENANT_ID`
   - `AZURE_SUBSCRIPTION_ID`

## Environment URLs

- **Staging**: {manifest['environments']['staging_url']}
- **Production**: {manifest['environments']['production_url']}
"""


def main():
    """Main entry point"""
    import sys
    
    if len(sys.argv) < 2:
        print("Usage: python azure_resource_manager.py <command> [options]")
        print("\nCommands:")
        print("  generate-infra <manifests.json> <output-dir>  - Generate infrastructure code")
        print("  provision-shared [--dry-run]                  - Provision shared resources")
        sys.exit(1)
    
    command = sys.argv[1]
    config = AzureConfig()
    manager = AzureResourceManager(config)
    
    if command == "generate-infra" and len(sys.argv) >= 4:
        manifests_file = Path(sys.argv[2])
        output_dir = Path(sys.argv[3])
        
        with open(manifests_file) as f:
            manifests = json.load(f)
        
        manager.generate_all_infrastructure(manifests, output_dir)
    
    elif command == "provision-shared":
        dry_run = "--dry-run" in sys.argv
        manager.provision_shared_resources(dry_run)
    
    else:
        print("Invalid command")
        sys.exit(1)


if __name__ == "__main__":
    main()
